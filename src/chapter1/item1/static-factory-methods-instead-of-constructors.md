Традиционный способ, которым класс позволяет клиенту получить экземпляр, — предоставление открытого (`public`)
конструктора. Существует еще один метод, который должен быть частью инструментария каждого программиста. Класс может
предоставить открытый статический фабричный метод. Вот простой пример из Boolean (упакованный примитивный класс
`boolean`). Этот метод преобразует значение примитивного типа `boolean` в ссылку на объект `Boolean`:

```java
public static Boolean valueOf(boolean b) {
    return b ? Boolean.TRUE : Boolean.FALSE;
}
```

Обратите внимание, что статический фабричный метод — это не то же самое, что проектный шаблон Фабричный Метод
(Factory Method) из [12]. Статический фабричный метод, описанный в этом разделе, не имеет прямого эквивалента в[12].

Класс может предоставить своим клиентам статические фабричные методы вместо открытых (public) конструкторов (или в
дополнение к ним). Такое предоставление статического фабричного метода вместо открытого конструктора имеет как
преимущества, так и недостатки.

Одним из преимуществ статических фабричных методов является то, что, в отличие от конструкторов, они имеют имена.
Если параметры конструктора не описывают возвращаемые объекты (и сами по себе не являются ими), то хорошо подобранное
имя статического фабричного метода легче в использовании, а получающийся в результате код оказывается более
удобочитаемым. Например, вместо конструктора `BigInteger(int, int, Random)`, который возвращает объект `BigInteger`,
который, вероятно, представляет собой простое число, было бы лучше использовать статический фабричный метод с именем
`BigInteger.probablePrime` (этот метод был добавлен в Java 4)

Класс может иметь только один конструктор с заданной сигнатурой. Программисты, как известно, обходят это ограничение
путём предоставления конструкторов, списки параметров которых отличаются только порядком их типов. Это плохая идея.
Пользователь такого API не сможет вспомнить, какой конструктор ему нужен, и в конечном итоге будет ошибаться и вызывать
неверный. Программисты, читающие код с такими конструкторами, без документации не будут знать, что он делает.

Благодаря наличию имён на статические фабричные методы не накладывается ограничение из предыдущего абзаца. В тех
случаях, когда классу, как представляется, требуется несколько конструкторов с одинаковой сигнатурой, замените
их статическими фабричными методами с тщательно подобранными именами, чтобы подчеркнуть различия.

**Вторым преимуществом статических фабричных методов является то, что, в отличие от конструкторов, они не обязаны
создавать новые объекты при каждом вызове**. Это позволяет неизменяемым классам (раздел 4.3) использовать предварительно
сконструированные экземпляры или кешировать их при создании, чтобы избежать ненужных дубликатов. Метод
`Boolean.valueOf(boolean)` иллюстрирует этот подход: он никогда не создаёт объект. Этот метод аналогичен
проектному шаблону _Приспособленец_ (Flyweight) [12]. Он может значительно улучшить производительность, если часто
запрашиваются эквивалентные объекты, особенно если их создание является дорогостоящим.

Возможность статических фабричных методов возвращать один и тот же объект при повторных вызовах позволяет классам строго
контролировать, какие экземпляры существуют в любой момент времени. Классы, которые работают таким образом, называются
классами с управлением экземплярами (instance-controlled). Существует несколько причин для написания таких классов.
Управление экземплярами позволяет классу гарантировать, что он является Singleton (Одиночка) (раздел 2.3) или
неинстанцируемым (раздел 2.4). Кроме того, это позволяет неизменяемому классу значения (раздел 4.3) гарантировать, что
не существует двух одинаковых экземпляров: `a.equals(b)` истинно тогда и только тогда, когда `a == b`. Это основа
проектного шаблона _Приспособленец_ [12]. Такую гарантию предоставляют типы перечислений (раздел 6.1).

**Третье преимущество статических фабричных методов заключается в том, что, в отличие от конструкторов, они могут
возвращать объект любого подтипа их возвращаемого типа.** Это даёт вам большую гибкость в выборе класса возвращаемого
объекта.

Одним из применений этой гибкости является то, что API может возвращать объекты, не делая их классы открытыми. Сокрытие
классов реализации таким способом приводит к очень компактному API. Эта техника _ведет к каркасам на основе интерфейсов_
(раздел 4.6), в которых интерфейсы предоставляют естественные возвращаемые типы для статических фабричных методов.

До Java 8 интерфейсы не могли иметь статических методов. По соглашению статические фабричные методы для интерфейса с
именем _Туре_ размещались в сопутствующем неинстанцируемом классе (раздел 2.4) с именем `Types`. Например, Java
Collections Framework содержит 45 реализаций интерфейсов, предоставляя неизменяемые, синхронизированные и т.п.
коллекции. Почти все эти реализации экспортируются с помощью статических фабричных методов в одном неинстанцируемом
классе (`java.util.Collections`). Все классы возвращаемых объектов являются закрытыми.

Collections Framework API гораздо меньше, чем потребовалось бы в случае экспорта 45 отдельных открытых классов, по
одному для каждой реализации. Это не только уменьшенный _размер_ API, но и меньший _концептуальный вес_: количество и
сложность концепций, которые программисты должны освоить для того, чтобы использовать это API. Программист знает, что
возвращаемый объект имеет API, в точности предусмотренный его интерфейсом, так что нет необходимости читать
дополнительную документацию для класса реализации. Кроме того, использование такого статического фабричного метода
требует от клиента обращения к возвращаемому объекту через интерфейс, а не через класс реализации, что в общем случае
является хорошей практикой (раздел 9.8).

В Java 8 было ликвидировано ограничение, что интерфейсы не могут содержать статические методы, так что теперь мало
причин для предоставления неинстанцируемого сопутствующего класса для интерфейса. Многие открытые статические члены,
которые ранее располагались в таком классе, теперь размещаются в самом интерфейсе. Обратите, однако, внимание, что
по-прежнему может оставаться необходимым поместить основную часть кода реализации этих статических методов в отдельный
класс, закрытый на уровне пакета. Дело в том, что Java 8 требует, чтобы все статические члены интерфейса были открытыми.
Java 9 разрешает иметь закрытые статические методы, но статические поля и статические классы-члены по-прежнему обязаны
быть открытыми.

**Четвертым преимуществом статических фабричных методов является то, что класс возвращённого объекта может варьироваться
от вызова к вызову в зависимости от входных параметров.** Допускается любой подтип объявленного типа возвращаемого
значения. Класс возвращённого объекта может также изменяться от выпуска к выпуску.

Класс `EnumSet` (раздел 6.3) не имеет открытых конструкторов, а только статические фабрики. В реализации OpenJDK они
возвращают экземпляр одного из двух подклассов в зависимости от размера базового типа перечисления: если в нём не более
64 элементов (как в большинстве перечислений), то статические фабрики возвращают экземпляр `RegularEnumSet`, который
реализуется как один `long`; если больше 64, то `JumboEnumSet` с массивом `long`.

Существование этих двух реализаций классов является невидимым для клиентов. Если `RegularEnumSet` перестанет давать
преимущества в производительности для малых перечислений, он может быть устранён из будущих версий без каких бы то ни
было последствий. Аналогично в будущую версию можно добавить третью или четвертую реализацию `EnumSet`, если она
окажется полезной для производительности. Клиенты не знают и не должны беспокоиться о классе объекта, который они
получают от фабрики; для них важно только, что это некоторый подкласс `EnumSet`.

**Пятое преимущество статических фабрик заключается в том, что класс возвращаемого объекта не обязан существовать во
время разработки класса, содержащего метод.** Такие гибкие статические фабричные методы образуют основу _каркасов
провайдеров служб_ (service provider frameworks) наподобие Java Database Connectivity API (JDBC). Каркас провайдера
службы представляет собой систему, в которой провайдер реализует службу, а система делает реализацию доступной для
клиентов, отделяя клиентов от реализаций.

Имеется три основных компонента каркаса провайдера службы: интерфейс службы, который представляет реализацию; API
регистрации провайдера, который провайдеры используют для регистрации реализации; и API доступа к службе, который
клиенты используют для получения экземпляров службы. API доступа к службе может позволить клиентам указать критерии
выбора реализации. В отсутствие таких критериев API возвращает экземпляр реализации по умолчанию или позволяет клиенту
циклически обойти все имеющиеся реализации. API доступа к службе представляет собой гибкую статическую фабрику, которая
лежит в основе каркаса провайдера службы.

Необязательный четвертый компонент каркаса провайдера службы представляет собой интерфейс провайдера службы, который
описывает объект фабрики, производящий экземпляры интерфейса службы. В отсутствие интерфейса провайдера службы
реализации должны инстанцироваться рефлективно (раздел 9.9). В случае JDBC `Connection` играет роль части интерфейса
службы, `DriverManager.registerDriver` представляет собой API регистрации провайдера, `DriverManager.getConnection` —
API доступа к службе, а `Driver` — интерфейс провайдера службы.

Имеется множество вариантов шаблонов каркасов провайдеров служб. Например, API доступа к службе может возвращать более
богатый интерфейс службы клиентам, чем представленной провайдерами. Это проектный шаблон _Мост_ (Bridge) [12].
Фреймворки внедрения зависимостей (раздел 2.5) можно рассматривать как мощные провайдеры служб. Начиная с Java 6,
платформа включает каркас провайдера служб общего назначения, `java.util.ServiceLoader`, так что вам не нужно (а в
общем случае и не стоит) писать собственный каркас (раздел 9.3). JDBC не использует `ServiceLoader`, так как
предшествует ему.

**Основное ограничение предоставления только статических фабричных методов заключается в том, что классы без открытых или
защищённых конструкторов не могут порождать подклассы.** Например, невозможно создать подкласс любого из классов
реализации в Collections Framework. Пожалуй, это может быть благом, потому что требует от программистов использовать
композицию, вместо наследования (раздел 4.4), и необходимо для неизменяемых типов (раздел 4.3).

**Вторым недостатком статических фабричных методов является то, что их трудно отличить от других статических методов.**
Они не выделены в документации API так же, как конструкторы, поэтому может быть трудно понять, как создать экземпляр
класса, предоставляемый статическим фабричным методом, вместо конструкторов. Инструментарий Javadoc, возможно,
когда-нибудь обратит внимание на статические фабричные методы. Указанный недостаток может быть смягчён путём привлечения
внимания статическим фабричным методам в документации класса или интерфейса, а также путём применения соглашений по
именованию. Ниже приведены некоторые распространенные имена для статических фабричных методов, и этот список является
далеко не исчерпывающим.
* **from** — метод преобразования, который получает один параметр и возвращает соответствующий экземпляр требуемого
типа, например:
`Date d = Date.from(instant);`
* **of** — метод агрегации, который получает несколько параметров и возвращает соответствующий экземпляр требуемого типа, объединяющий
их, например: 
`Set<Rank> faceCards = EnumSet.of(JACK, QUEEN, KING);`
* **valueOf** — более многословная альтернатива from и of, например: 
`BigInteger prime = BigInteger.valueOf(Integer.MAX_VALUE);`
* **instance** или **getInstance** — возвращает экземпляр, описываемый параметрами (если таковые имеются), но о котором
нельзя сказать, что он имеет то же значение, например: 
`StackWalker luke = StackWalker.getInstance(options);`
* **create** или **newInstance** — подобен _instance_ или _getInstance_, но отличается тем, что гарантирует, что каждый
вызов даёт новый экземпляр, например:
`Object newArray = Array.newInstance(classObject, arrayLen);`
* **getType** — подобен **getInstance**, но используется, если фабричный метод находится в другом классе. Туре
представляет собой тип объекта, возвращаемого фабричным методом, например:
`FileStore fs = Files.getFileStore(path);`
* **newType** — подобен _newInstance_, но используется, если фабричный метод находится в другом классе. Туре
представляет собой тип объекта, возвращаемого фабричным методом, например:
`BufferedReader br = Files.newBufferedReader(path);`
* **type**— краткая альтернатива для _getType_ и _newType_, например:
`List<Complaint> litany = Collections.list(legacyLitany);`

Итак, могут использоваться как статические фабричные методы, так и открытые конструкторы, и следует уделить внимание
преимуществам одних перед другими. Часто статические фабрики являются предпочтительнее, так что гасите свой первый порыв
предоставления открытого конструктора классу, не рассмотрев вначале возможность использования статических фабрик.


